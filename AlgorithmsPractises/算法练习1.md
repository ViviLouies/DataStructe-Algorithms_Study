# 算法练习1

标签（空格分隔）： 算法

---

记录算法练习中的练习题以及实现的代码，练习题主要是来自[Hihocoder][1]。主要还是按照级别，由简单到难的顺序练习。

##### 题1 A+B
  第一题来自[A + B][2]，输入两个整数，输出其相加的结果。题目描述如下：
  
  ![此处输入图片的描述][3]
  
  实现的代码如下：
```
#include<iostream>
using std::cin;
using std::cout;

int main(){
	int a, b;
	while (cin >> a >> b){
		cout << a + b << "\n";
	}

	return 0;
}
```

这题是非常简单的一道题目了。

##### 题2 字符消除
  第二题是[字符消除][4]，描述如下：
  
  ![此处输入图片的描述][5]
  
  ![此处输入图片的描述][6]
  
  这道题目一开始打算使用`char`数组，但是感觉还是不如使用`string`类方面，最终实现代码如下：
  
```
#include<iostream>
#include<string>

using std::cin;
using std::cout;
using std::endl;
using std::string;

// 返回消除的字符数
int getDelStrNums(const string& str){
	int resultNums = 0;
	string tmp(str);
	// 初始字符长度
	int beforeLength = tmp.size();
	// 开始执行消除字符操作
	while (!tmp.empty()){
		string finalStr;
		for (int i = 0; i < tmp.size()-1; i++){
			if (tmp[i] == tmp[i + 1]){
				// 如果连续两个字符相等，则继续判断有连续几个字符相等
				while (i < tmp.size() - 1 && tmp[i] == tmp[i + 1]){
					i++;
				}
			}
			else{
				finalStr.append(1, tmp[i]);
			}
		}
		if (tmp.size() == 1 || tmp[tmp.size() - 2] != tmp[tmp.size() - 1]){
			// 最后一个字符和倒数第二个字符不相等的话
			finalStr.append(1, tmp[tmp.size() - 1]);
		}
		if (tmp.size() == finalStr.size()){
			// 消除前字符长度与执行消除操作后的字符长度相等，说明已经没有字符可以消除
			tmp.clear();
			tmp.assign(finalStr.begin(), finalStr.end());
			break;
		}
		// 分配好剩余字符
		tmp.clear();
		tmp.assign(finalStr.begin(), finalStr.end());
	}

	// 得到最终的消除字符数
	resultNums = beforeLength - tmp.size();

	return resultNums;
}

// 先对输入的字符插入A~C中的一个字符以获得最大的消除字符数
int insertStr(const string& str){
	int maxNums = 0;

	char insertStr[] = { 'A', 'B', 'C' };
	for (int i = 0; i <= str.size(); i++){
		for (int k = 0; k < 3; k++){
			// 轮流插入3个字符中的一个
			string input(str);
			if (i == str.size()){
				// 在输入字符末尾插入一个字符
				input += insertStr[k];
			}
			else{
				input.insert(i, 1, insertStr[k]);
			}
			// 获取消除的总字符数
			int delNums = getDelStrNums(input);
			maxNums = (delNums >= maxNums) ? delNums : maxNums;
		}
	}
	return maxNums;
}

int main(){
	int nums = 0;
	cin >> nums;

	for (int i = 0; i < nums; i++){
		string input;
		cin >> input;
		cout << insertStr(input) << endl;
	}

	system("pause");
	return 0;
}
```

##### 题3 补提交卡
  第三题是[补提交卡][7]，描述如下：
  
  ![此处输入图片的描述][8]
  
  实现代码如下：
```
#include<iostream>
using std::cin;
using std::cout;
using std::endl;

// 计算补交天数后最长连续提交的天数
int getLongestDays(int a[], int n, int m){
	int maxDays = 0;
	if (m >= n)
		// 补交天数大于等于缺交天数时
		maxDays = 100;
	else{
		for (int k = 0; k <= n - 1; k++){
			int days = 0;
			if (k <= m){
				// 少于补交天数的时候
			    days = a[k]-1;
			}
			else if (k == n - m-1){
				days = 100 - a[k]-1;
			}
			else{
				days = a[k] - a[k - m-1]-1;
			}
			maxDays = (days > maxDays) ? days : maxDays;
		}
	}
	return maxDays;
}

int main(){
	int nums = 0;
	cin >> nums;

	for (int i = 0; i < nums; i++){
		// N 是错失提交的天数，M是可以补交的天数
		int N=0, M=0;
		cin >> N >> M;
		int *a = new int[N];
		for (int j = 0; j < N; j++)
			cin >> a[j];
		
		cout << getLongestDays(a, N, M) << endl;
		delete[] a;
	}

	system("pause");
	return 0;
}
```



  [1]: http://hihocoder.com/problemset
  [2]: http://hihocoder.com/problemset/problem/1000
  [3]: http://7xrluf.com1.z0.glb.clouddn.com/algorithm1.png
  [4]: http://hihocoder.com/problemset/problem/1039
  [5]: http://7xrluf.com1.z0.glb.clouddn.com/algorithm2.png
  [6]: http://7xrluf.com1.z0.glb.clouddn.com/algorithm3.png
  [7]: http://hihocoder.com/problemset/problem/1051
  [8]: http://7xrluf.com1.z0.glb.clouddn.com/algorithm4.png