### 算法题笔记

记录来自《剑指Offer》上的面试题目。

##### 1. 二维数组的查找

> 题目：在一个二维数组中，每一行按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有这个整数。

下面给出一个题目所要求的二维数组：

```mathematica
1 2 8 9 
2 4 9 12
4 7 10 13
6 8 11 15
```

这道题目的解法是选择右上角或者左下角的数组元素来进行查找。比如，以选择右上角的数组元素为例，当选择的数值大于要查找的整数值，如上述数组中的9，要查找的是7，那么9是第四列的最小值，所以这样就排除了第四列，7就应该存在前三列中，这个时候就选择前三列数组的右上角，也就是9左边的8，然后8还是大于7，进一步排除第三列，继续选择前两列的右上角元素--2，这个时候2就小于7，那么7应该是位于2的右边或者下边，但右边已经查找过，并且被剔除了，所以就只有其下边的这种可能性，此时就剔除第一行了，选择剩下的第二行到第四行和前两列的区域的右上角元素--4，4还是小于7，然后同样剔除所在的行，往下查找，然后就找到7了。

总结上述查找的规律：**首先选择数组中右上角的数字。如果该数字等于要查找的数字，查找过程结束；如果该数字大于要查找的数字，剔除这个数字所在的列；如果该数字小于要查找的数字，剔除这个数字所在的行。**通过这样的查找，每次查找都可以剔除一行或者一列，每一步都可以缩小范围，直到查找到所查找的数字或者发现查找的数字不存在数组中。

下面是给出实现的函数代码和测试代码：

```c++
// 二维数组的查找
bool Find(int* matrix, int rows, int columns, int number){
	bool found = false;
	if (matrix != NULL && rows > 0 && columns > 0){
		int row = 0;
		// 从右上角开始查找
		int column = columns - 1;
		while (row < rows && column >= 0){
			if (matrix[row * columns + column] == number){
				found = true;
				break;
			}
			else if (matrix[row * columns + column] > number)
				column--;
			else
				row++;
		}
	}
	return found;
}
// 测试
int main(void){
	int rows =  4;
	int columns = 4;
	int a[4][4] = {
		{ 1, 2, 8, 9 }, { 2, 4, 9, 12 }, { 4, 7, 10, 13 }, {6, 8, 11, 15}
	};
	int *matrix = a[0];
    // 二维数组包含查找的数字
	cout <<"find 7 in matrix:"<< Find(matrix, rows, columns, 7) << endl;
	// 二维数组不包含查找的数字，数字大于数组的最大值
	cout << "find 16 in matrix: " << Find(matrix, rows, columns, 16) << endl;
	// 二维数组不包含查找的数字，数字小于数组的最小值
	cout << "find 0 in matrix: " << Find(matrix, rows, columns, 0) << endl;
	// 二维数组不包含查找的数字，数字介于数组最大值和最小值之间
	cout << "find 3 in matrix: " << Find(matrix, rows, columns, 3) << endl;
	int *matrix_null = NULL;
    // 测试输入空指针的情况
	cout << "find 7 in matrix: " << Find(matrix_null, rows, columns, 7) << endl;

	system("pause");
	return 0;
}
```

选择左下角的数字也是可以实现同样的效果，只是这种情况所剔除是行还是列刚好相反，当这个数字大于所查找的数字，是剔除这个数字所在的行；这个数字小于所查找的数字，剔除这个数字所在的列。

##### 2.替换空格

这是一道有关字符串的问题。首先在C/C++中，会把常量字符串放到单独的一个内存区域中，**当几个指针赋值给相同的常量字符串时，它们实际上会指向相同的内存地址；但如果用常量内存初始化数组，数组的地址是不相同的。**

下面给出替换空格的题目：

> 请实现一个函数，把字符串中的每个空格替换成"%20"。例如输入“We are happy."， 则输出"We%20are%20happy."。

在网络编程中，对于含有特殊字符的URL参数，如空格，”#“等，可能导致服务器端无法获得正确的参数值。我们需要将这些特殊符号转换成服务器可以识别的字符，替换的规则是在'%'后面跟上ASCII码的两位十六进制的表示。比如空格的ASCII码是32，即十六进制的`0x20`，因此空格被替换成"%20"。

这里首先需要分两种情况，第一种是在原来的字符串上做替换；第二种是创建新的字符串并在新的字符串上做替换。现在假设是第一种情况，在原来的字符串上做替换并保证输入的字符串后面留有足够的空余内存。

最直观的做法是从头到尾扫描字符串，每一层碰到空格字符的时候做替换，由于需要将1个字符替换成3个字符，所以每次替换的时候，都要将空格后面的字符都往后移动两个字节，否则就有两个字符被替换了。因此，这种做法的时间复杂度是$O(n^2)$。

上述做法是从前往后替换，现在可以换个思路，从后往前进行替换。首先是先遍历一遍字符串，计算字符串中空格的总数，由此计算出替换之后字符串的总长度，这里是每替换一个空格就需要增加两个字节的长度，因此替换之后的字符串长度应该是原来的长度加上两倍的空格数目。然后从后面开始复制和替换空格，需要准备两个指针P1和P2，P1指向当前字符串末尾，P2指向替换之后的字符串的末尾，然后向前移动P1，逐个把它指向的字符复制到P2指向的位置，而遇到空格的时候，P2就需要向前移动3格，因为需要复制过来的是3个字符，而P1还是移动一位。而当P2和P1都指向同一个位置的时候，说明所有空格都替换完毕了。

这种做法的时间复杂度是$O(n)$，效率是远高于第一种做法，下面给出这种做法的代码实现和测试例子。

```c++
#include<iostream>
using std::cout;
using std::endl;
using std::cin;

// 替换空格,length是字符数组string的总容量
void ReplaceBlank(char string[], int length){
	if (string == NULL || length <= 0){
		return;
	}
	// 字符串string的实际长度
	int originLength = 0;
	int numberOfBlank = 0;
	int i = 0;
	// 统计空格的数量和字符的数量
	while (string[i] != '\0'){
		++originLength;
		if (string[i] == ' ')
			++numberOfBlank;
		++i;
	}
	// 替换空格后的字符串新长度
	int newLength = originLength + numberOfBlank * 2;
	if (newLength > length)
		return;

	int indexOfOriginal = originLength;
	int indexOfNew = newLength;
	while (indexOfOriginal >= 0 && indexOfNew > indexOfOriginal){
		if (string[indexOfOriginal] == ' '){
			string[indexOfNew--] = '0';
			string[indexOfNew--] = '2';
			string[indexOfNew--] = '%';
		}
		else{
			string[indexOfNew--] = string[indexOfOriginal];
		}
		indexOfOriginal--;
	}
}

// 测试
int main(void){
	char str[10] = " hello";
	char str2[10] = "he llo";
	char str3[10] = "hello ";
	char str4[30] = "We  are  happy.";
	char str5[30] = "helloWorld.";
	char *str6 = NULL;
	char str7[10] = "";
	char str8[10] = " ";
	char str9[20] = "     ";
	// 空格位于字符串的最前面
	cout << "origin: " << str;
	ReplaceBlank(str, 10);
	cout << ",--> " << str << endl;
	// 空格位于字符串的最后面
	cout << "origin: " << str2;
	ReplaceBlank(str2, 10);
	cout << ",--> " << str2 << endl;
	// 空格位于字符串的中间
	cout << "origin: " << str3;
	ReplaceBlank(str3, 10);
	cout << ",--> " << str3 << endl;
	// 字符串中有多个连续空格
	cout << "origin: " << str4;
	ReplaceBlank(str4, 30);
	cout << ",--> " << str4 << endl;
	// 输入的字符串没有空格
	cout << "origin: " << str5;
	ReplaceBlank(str5, 30);
	cout << ",--> " << str5 << endl;
	// 字符串是空指针
//	cout << "origin: " << str6;
	ReplaceBlank(str6, 10);
//	cout << ",--> " << str6 << endl;
	// 字符串是空字符串
	cout << "origin: " << str7;
	ReplaceBlank(str7, 10);
	cout << ",--> " << str7 << endl;
	// 字符串只有一个空格字符
	cout << "origin: " << str8;
	ReplaceBlank(str8, 10);
	cout << ",--> " << str8 << endl;
	// 字符串中只有多个连续空格
	cout << "origin: " << str9;
	ReplaceBlank(str9, 20);
	cout << ",--> " << str9 << endl;

	system("pause");
	return 0;
}
```

这种从后往前复制的思路还可以用在合并两个数组的情况。

